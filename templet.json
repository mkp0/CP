{
  "mkp": {
    "prefix": "mkp",
    "body": [
      "#include <bits/stdc++.h>",
      "",
      "#define ll long long",
      "#define pi (3.141592653589)",
      "#define all(x) (x).begin(), (x).end()",
      "#define vi vector<int>",
      "#define vll vector<long long>",
      "#define pii pair<int, int>",
      "#define pll pair<long long, long long>",
      "#define pb push_back",
      "#define mp make_pair",
      "#define S second",
      "#define loop(i, a, b, c) for (int i = (a); i <= (b); i= i + (c))",
      "#define MOD 1e9 + 7",
      "using namespace std;",
        "",
      "// trie trie, zalgo Z-Algorithm, segTree Segmentation Tree, BS binary Search , subStr Substring , mrg Merge,SOE sieve of Era,permutate PermutationOfString ,graphi GraphIntialzation , graphBFS Graph BFS ,graphDFS graph DFS,exdGCD ExtendedGCD,nCR with Factorial ,axbyn ax+by=n  ",
      "",
      "/* I am gonna be the King of the Pirates */",
      "",
      "void solve()",
      "{",
      "     $1",
      "}",
      "",
      "int32_t main()",
      "{",
      "//#ifndef ONLINE_JUDGE",
      "    //freopen(\"input.txt\", \"r\", stdin);",
      "    //freopen(\"output.txt\", \"w\", stdout);",
      "//#endif",
      "    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
      "    int t;",
      "    cin >> t;",
      "    while (t--)",
      "    {",
      "        solve();",
      "    }",
      "    return 0;",
      "}"
    ],
    "description": "mkp"
  },
  "subString": {
    "prefix": "subStr",
    "body": [
      "void subString(string in, string ou)",
      "{",
      "    if (in.size() == 0)",
      "    {",
      "        cout << ou << endl;",
      "    }",
      "    else",
      "    {",
      "        subString(in.substr(1), ou);",
      "        subString(in.substr(1), ou + in[0]);",
      "    }",
      "}"
    ],
    "description": "subString"
  },
  "Merge": {
    "prefix": "mrg",
    "body": [
      "void merge(int arr[], int l, int m, int r)",
      "{",
      "    int i, j, k;",
      "    int n1 = m - l + 1;",
      "    int n2 = r - m;",
      "    int L[n1], R[n2];",
      "    for (i = 0; i < n1; i++)",
      "        L[i] = arr[l + i];",
      "    for (j = 0; j < n2; j++)",
      "        R[j] = arr[m + 1 + j];",
      "    i = 0; // Initial index of first subarray",
      "    j = 0; // Initial index of second subarray",
      "    k = l; // Initial index of merged subarray",
      "    while (i < n1 && j < n2)",
      "    {",
      "        if (L[i] <= R[j])",
      "        {",
      "            arr[k] = L[i];",
      "            i++;",
      "        }",
      "        else",
      "        {",
      "            arr[k] = R[j];",
      "            j++;",
      "        }",
      "        k++;",
      "    }",
      "",
      "    while (i < n1)",
      "    {",
      "        arr[k] = L[i];",
      "        i++;",
      "        k++;",
      "    }",
      "    while (j < n2)",
      "    {",
      "        arr[k] = R[j];",
      "        j++;",
      "        k++;",
      "    }",
      "}"
    ],
    "description": "Merge"
  },
  "BinarySearch": {
    "prefix": "BS",
    "body": [
      "int binarySearch(int arr[], int l, int r, int x)",
      "{",
      "    if (r >= l)",
      "    {",
      "        int mid = l + (r - l) / 2;",
      "",
      "        if (arr[mid] == x)",
      "            return mid;",
      "        if (arr[mid] > x)",
      "            return binarySearch(arr, l, mid - 1, x);",
      "        return binarySearch(arr, mid + 1, r, x);",
      "    }",
      "    return -1;",
      "}"
    ],
    "description": "BinarySearch"
  },
  "SieveOfEratoshenes": {
    "prefix": "SOE",
    "body": [
      "void SieveOfEratosthenes(int n)",
      "{",
      "    bool prime[n + 1];",
      "    memset(prime, true, sizeof(prime));",
      "",
      "    for (int p = 2; p * p <= n; p++)",
      "    {",
      "        if (prime[p] == true)",
      "        {",
      "            for (int i = p * p; i <= n; i += p)",
      "                prime[i] = false;",
      "        }",
      "    }",
      "",
      "    for (int p = 2; p <= n; p++)",
      "        if (prime[p])",
      "            cout << p << \" \";",
      "}"
    ],
    "description": "SieveOfEratoshenes"
  },
  "PermuatationOfString": {
    "prefix": "permutate",
    "body": [
      "void permute(string a, int l, int r)  ",
      "{  ",
      "    if (l == r)  ",
      "        cout<<a<<endl;  ",
      "    else",
      "    {   ",
      "        for (int i = l; i <= r; i++)  ",
      "        {  ",
      "            swap(a[l], a[i]);  ",
      "  ",
      "            permute(a, l+1, r);  ",
      "  ",
      "            swap(a[l], a[i]);  ",
      "        }  ",
      "    }  ",
      "} "
    ],
    "description": "PermuatationOfString"
  },
  "Graph Intialization": {
    "prefix": "graphi",
    "body": [
      "class Graph",
      "{",
      "    int V;",
      "    list<int> *adj;",
      "public:",
      "    Graph(int V);",
      "    void addEdge(int v, int w);",
      "    void BFS(int s);",
      "    void DFS(int s);",
      "    void DFSUtil(int s,bool visited[]);",
      "};",
      "Graph::Graph(int V)",
      "{",
      "    this->V = V;",
      "    adj = new list<int>[V];",
      "}",
      "void Graph::addEdge(int v, int w)",
      "{",
      "    adj[v].push_back(w);",
      "}"
    ],
    "description": "Graph Intialization"
  },
  "Graph BFS": {
    "prefix": "graphBFS",
    "body": [
      "void Graph::BFS(int s) ",
      "{ ",
      "    bool *visited = new bool[V]; ",
      "    for(int i = 0; i < V; i++) ",
      "        visited[i] = false; ",
      "    list<int> queue; ",
      "  ",
      "    visited[s] = true; ",
      "    queue.push_back(s); ",
      "  ",
      "    list<int>::iterator i; ",
      "  ",
      "    while(!queue.empty()) ",
      "    { ",
      "        s = queue.front(); ",
      "        cout << s << \" \"; ",
      "        queue.pop_front(); ",
      "        for (i = adj[s].begin(); i != adj[s].end(); ++i) ",
      "        { ",
      "            if (!visited[*i]) ",
      "            { ",
      "                visited[*i] = true; ",
      "                queue.push_back(*i); ",
      "            } ",
      "        } ",
      "    } ",
      "} "
    ],
    "description": "Graph BFS"
  },
  "extendedGCD": {
    "prefix": "exdGCD",
    "body": [
      "int gcdExtended(int a, int b, int *x, int *y)  ",
      "{  ",
      "    if (a == 0)  ",
      "    {  ",
      "        *x = 0;  ",
      "        *y = 1;  ",
      "        return b;  ",
      "    }  ",
      "    int x1, y1;",
      "    int gcd = gcdExtended(b%a, a, &x1, &y1);  ",
      "      *x = y1 - (b/a) * x1;  ",
      "    *y = x1;  ",
      "  ",
      "    return gcd;  ",
      "} "
    ],
    "description": "extendedGCD"
  },
  "GraphDFS": {
    "prefix": "GraphDFS",
    "body": [
      "void Graph::DFSUtil(int v, bool visited[]) ",
      "{ ",
      "    visited[v] = true; ",
      "    cout << v << \" \"; ",
      "  ",
      "    list<int>::iterator i; ",
      "    for (i = adj[v].begin(); i != adj[v].end(); ++i) ",
      "        if (!visited[*i]) ",
      "            DFSUtil(*i, visited); ",
      "} ",
      "  ",
      "void Graph::DFS(int v) ",
      "{ ",
      "    bool *visited = new bool[V]; ",
      "    for (int i = 0; i < V; i++) ",
      "        visited[i] = false; ",
      "  ",
      "    DFSUtil(v, visited); ",
      "} "
    ],
    "description": "GraphDFS"
  },
  "nCr": {
    "prefix": "nCr",
    "body": [
      "int nCr(int n, int r) ",
      "{ ",
      "    return fact(n) / (fact(r) * fact(n - r)); ",
      "} ",
      "  ",
      "int fact(int n) ",
      "{ ",
      "    int res = 1; ",
      "    for (int i = 2; i <= n; i++) ",
      "        res = res * i; ",
      "    return res; ",
      "} "
    ],
    "description": "nCr"
  },
  "ax + by = n": {
    "prefix": "axbyn",
    "body": [
      "void axbyn(int a, int b, int n) ",
      "{ ",
      "    // traverse for all possible values ",
      "    for (int i = 0; i * a <= n; i++) { ",
      "  ",
      "        // check if it is satisfying the equation ",
      "        if ((n - (i * a)) % b == 0) { ",
      "            cout << \"x = \" << i << \", y = \" ",
      "                 << (n - (i * a)) / b; ",
      "            return; ",
      "        } ",
      "    } ",
      "  ",
      "    cout << \"No solution\"; ",
      "}"
    ],
    "description": "ax + by = n"
  },
  "segTree": {
    "prefix": "segTree",
    "body": [
      "// A utility function to get the middle index from corner indexes. ",
      "int getMid(int s, int e) {  return s + (e -s)/2;  } ",
      "   ",
      "/*  A recursive function to get the xor of values in a given range of the array. The following are parameters for this function. ",
      "   ",
      "    st    --> Pointer to segment tree ",
      "    si    --> Index of current node in the segment tree. Initially ",
      "              0 is passed as root is always at index 0 ",
      "    ss & se  --> Starting and ending indexes of the segment ",
      "                 represented by current node, i.e., st[si] ",
      "    qs & qe  --> Starting and ending indexes of query range */",
      "int getXorUtil(int *st, int ss, int se, int qs, int qe, int si) ",
      "{ ",
      "    // If segment of this node is a part of given range, then return ",
      "    // the xor of the segment ",
      "    if (qs <= ss && qe >= se) ",
      "        return st[si]; ",
      "   ",
      "    // If segment of this node is outside the given range ",
      "    if (se < qs || ss > qe) ",
      "        return 0; ",
      "   ",
      "    // If a part of this segment overlaps with the given range ",
      "    int mid = getMid(ss, se); ",
      "    return getXorUtil(st, ss, mid, qs, qe, 2*si+1) ^ ",
      "           getXorUtil(st, mid+1, se, qs, qe, 2*si+2); ",
      "} ",
      "   ",
      "void updateValueUtil(int *st, int ss, int se, int i, int diff, int si) ",
      "{ ",
      "    if (i < ss || i > se) ",
      "        return; ",
      "",
      "    st[si] = st[si] + diff; ",
      "    if (se != ss) ",
      "    { ",
      "        int mid = getMid(ss, se); ",
      "        updateValueUtil(st, ss, mid, i, diff, 2*si + 1); ",
      "        updateValueUtil(st, mid+1, se, i, diff, 2*si + 2); ",
      "    } ",
      "} ",
      "   ",
      "// The function to update a value in input array and segment tree. ",
      "// It uses updateValueUtil() to update the value in segment tree ",
      "void updateValue(int arr[], int *st, int n, int i, int new_val) ",
      "{ ",
      "    // Check for erroneous input index ",
      "    if (i < 0 || i > n-1) ",
      "    { ",
      "        printf(\"Invalid Input\"); ",
      "        return; ",
      "    } ",
      "   ",
      "    // Get the difference between new value and old value ",
      "    int diff = new_val - arr[i]; ",
      "   ",
      "    // Update the value in array ",
      "    arr[i] = new_val; ",
      "   ",
      "    // Update the values of nodes in segment tree ",
      "    updateValueUtil(st, 0, n-1, i, diff, 0); ",
      "} ",
      "   ",
      "// Return xor of elements in range from index qs (quey start) ",
      "// to qe (query end).  It mainly uses getXorUtil() ",
      "int getXor(int *st, int n, int qs, int qe) ",
      "{ ",
      "    // Check for erroneous input values ",
      "    if (qs < 0 || qe > n-1 || qs > qe) ",
      "    { ",
      "        printf(\"Invalid Input\"); ",
      "        return -1; ",
      "    } ",
      "   ",
      "    return getXorUtil(st, 0, n-1, qs, qe, 0); ",
      "} ",
      "   ",
      "// A recursive function that constructs Segment Tree for array[ss..se]. ",
      "// si is index of current node in segment tree st ",
      "int constructSTUtil(int arr[], int ss, int se, int *st, int si) ",
      "{ ",
      "    // If there is one element in array, store it in current node of ",
      "    // segment tree and return ",
      "    if (ss == se) ",
      "    { ",
      "        st[si] = arr[ss]; ",
      "        return arr[ss]; ",
      "    } ",
      "   ",
      "    int mid = getMid(ss, se); ",
      "    st[si] =  constructSTUtil(arr, ss, mid, st, si*2+1) ^ ",
      "              constructSTUtil(arr, mid+1, se, st, si*2+2); ",
      "    return st[si]; ",
      "} ",
      "   ",
      "/* Function to construct segment tree from given array. This function ",
      "   allocates memory for segment tree and calls constructSTUtil() to ",
      "   fill the allocated memory */",
      "/*",
      "    Build segment tree from given array ",
      "    int *st = constructST(arr, n);  ",
      "*/",
      "int *constructST(int arr[], int n) ",
      "{ ",
      "    // Allocate memory for segment tree ",
      "   ",
      "    //Height of segment tree ",
      "    int x = (int)(ceil(log2(n)));  ",
      "   ",
      "    //Maximum size of segment tree ",
      "    int max_size = 2*(int)pow(2, x) - 1;  ",
      "   ",
      "    // Allocate memory ",
      "    int *st =  (int *)malloc(sizeof(int)*max_size); ",
      "   ",
      "    // Fill the allocated memory st ",
      "    constructSTUtil(arr, 0, n-1, st, 0); ",
      "   ",
      "    // Return the constructed segment tree ",
      "    return st; ",
      "} "
    ],
    "description": "segTree"
  },
  "zalgo": {
    "prefix": "zalgo",
    "body": [
      "void createZarray(string str, int Z[]){",
      "   int n = str.length();",
      "   int L, R, k;",
      "   L = R = 0;",
      "   for (int i = 1; i < n; ++i){",
      "      if (i > R){",
      "         L = R = i;",
      "         while (R<n && str[R-L] == str[R])",
      "         R++;",
      "         Z[i] = R-L;",
      "         R--;",
      "      } else {",
      "         k = i-L;",
      "         if (Z[k] < R-i+1)",
      "            Z[i] = Z[k];",
      "         else {",
      "            L = i;",
      "            while (R<n && str[R-L] == str[R])",
      "               R++;",
      "            Z[i] = R-L;",
      "            R--;",
      "         }",
      "      }",
      "   }",
      "}",
      "void zAlgorithm(string text, string pattern){",
      "   string str = pattern+\"$\"+text;",
      "   int len = str.length();",
      "   int Z[len];",
      "   createZarray(str, Z);",
      "   for (int i = 0; i < len; ++i){",
      "      if (Z[i] == pattern.length())",
      "         cout<<(i-pattern.length()-1)<<\"\\t\";",
      "   }",
      "}"
    ],
    "description": "zalgo"
  },
  "trie": {
    "prefix": "trie",
    "body": [
      "/*structuring the trie*/",
      "struct Trie",
      "{",
      "    string key;",
      "    int cnt;",
      "    unordered_map<char, Trie *> map;",
      "};",
      "",
      "/* Function to return a new Trie node */",
      "Trie *getNewTrieNode()",
      "{",
      "    Trie *node = new Trie;",
      "    node->cnt = 0;",
      "    return node;",
      "}",
      "",
      "/* function to insert a string */",
      "void insert(Trie *&root, string &str)",
      "{",
      "    // start from root node",
      "    Trie *temp = root;",
      "",
      "    for (int i = 0; i < str.length(); i++)",
      "    {",
      "",
      "        char x = str[i];",
      "",
      "        /*a new node if path doesn't exists*/",
      "        if (temp->map.find(x) == temp->map.end())",
      "            temp->map[x] = getNewTrieNode();",
      "",
      "        // go to next node",
      "        temp = temp->map[x];",
      "    }",
      "",
      "    // store key and its count in leaf nodes",
      "    temp->key = str;",
      "    temp->cnt += 1;",
      "}",
      "",
      "/* function for preorder traversal */",
      "bool triepreorder(Trie *temp, int &maxcnt, string &key)",
      "{",
      "    if (temp == NULL)",
      "        return false;",
      "",
      "    for (auto it : temp->map)",
      "    {",
      "",
      "        if (maxcnt < it.second->cnt)",
      "        {",
      "            key = it.second->key;",
      "            maxcnt = it.second->cnt;",
      "        }",
      "",
      "        triepreorder(it.second, maxcnt, key);",
      "    }",
      "}",
      "",
      "void trieOp(string arr[], int n)",
      "{",
      "    // Insert all words in a Trie",
      "    Trie *root = getNewTrieNode();",
      "    for (int i = 0; i < n; i++)",
      "        insert(root, arr[i]);",
      "",
      "    // Do preorder traversal to find the",
      "    // most frequent word",
      "    string key;",
      "    int cnt = 0;",
      "    triepreorder(root, cnt, key);",
      "}"
    ],
    "description": "trie"
  }
}
